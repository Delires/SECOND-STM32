#include "led.h"
#include "delay.h"
#include "key.h"
#include "sys.h"
#include "usart.h"
#include "sys.h"
 
/************************************************
参考<官方开发手册>P29总线架构
参考<stm32-Datasheet>P28存储器映像
************************************************/ 
/************************************************
把位带区转换为位带别名区
1.原理： 给寄存器的每个位赋予一个新地址，这每个位就会膨胀成一个字(4个字节32bit，因为32bit操作最
         快)。然后对这个字地址操作就相当于给这个“寄存器的位”进行操作。但这个字只有最低位有效。
2.两个部分有位带操作   片上外设   片上SRAM
3.转化公式如下：
   片上外设:Addr=0x4200 0000+(A-0x4000 0000)*8*4+N*4
   片上SRAM:Addr=0x2200 0000+(A-0x2000 0000)*8*4+N*4
4.把公式转化为程序语言如下：
   (addr&0xF000 0000)+ 0x0200 0000 +((addr&0x00FF FFFF)<<5)+(bitnum<<2)
   	①(addr&0xF000 0000)取出最高位 
	② +0x0200 0000 加上次高位，片上外设和片上SRAM的次高位都是0x0200 0000 
	③ (addr&0x00FF FFFF)取出低6位，高两位怎么都会被减掉
	④ <<5 = 8*4
	⑤ bitnum= <<2N*4
************************************************/

//计算公式如下：AliasAddr=0x4200 0000+((A-0x4000 0000)*4*8)+N*4
//整合为程序语言:AliasAddr=(0xF000 0000 & Addr)+0x0200 0000 +( (Addr&0x00FF FFFF)<<5) + (bitnum<<2)
 
//#define AliasAddr(addr,bitnum)  (0xF000 0000 & Addr)+0x0200 0000 +( (Addr&0x00FF FFFF)<<5) + (bitnum<<2)
/***********************************************************************************/
/********************************  位带操作的核心部分 ********************************/
/***********************************************************************************/
#define    PB_ODR    (0X40010C00+0X0C)   //写数据必须连续，不能断开
#define    PBout1(n)     *(u32*)((0xF0000000 & PB_ODR)+0x02000000 +((PB_ODR&0x00FFFFFF)<<5) + (n<<2) )
                       //(u32*)xxx 把数据变为指针     *((u32*)xxx)取这个指针的值进行赋值
#define    PE_ODR    (0x40011800+0X0C)   //写数据必须连续，不能断开
#define    PEout1(n)     *(u32*)((0xF0000000 & PE_ODR)+0x02000000 +((PE_ODR&0x00FFFFFF)<<5) + (n<<2) )


/**************************************************************************************************/
/*********************** 宏定义编写函数 模仿sys.h的宏定义 来把位带区转换为位带别名区*****************/
/************************宏定义编写函数 构造出一个计算函数 *****************************************/
/**************************************************************************************************/
#define    ALIAS_VALUE(addr, n)               ( (0xF0000000 & addr)+0x02000000+( (addr&0x00FFFFFF)<<5 ) +(n<<2) )
#define    POINTER_EXCHANGE(address)          *((volatile unsigned int *)(address))  //转换的数据值化为指针 并且取值 
#define    ALIAS_ADDR(addr, n)                POINTER_EXCHANGE(ALIAS_VALUE(addr, n))

#define    PBout2(n)                          ALIAS_ADDR(GPIOB_ODR_Addr, n) 




 int main(void)
 {		 
	delay_init();	    	 //延时函数初始化	  
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级
	uart_init(115200);	  //串口初始化为115200
 	LED_Init();			  //LED端口初始化
	KEY_Init();           //初始化与按键连接的硬件接口
 	while(1)
	{

/**  根据宏定义 位带操作 **/
		PBout1(5)=1;
		PEout1(5)=1;
		delay_ms(500);
		PBout1(5)=0;
		PEout1(5)=0;
		delay_ms(500);
		printf("%d     %d\r\n", sizeof(int), sizeof(long));
///*****************************  宏定义编写函数  位带函数定义********************/		
//		PBout2(5)=1;
//		delay_ms(500);
//		PBout2(5)=0;
//		delay_ms(500);
	}	 
 }

 
 
 

